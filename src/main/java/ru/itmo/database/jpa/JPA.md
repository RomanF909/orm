### Требования к ENTITY классам (согласно стандарту JPA)

1. В entity классе должен быть public или protected конструктор без аргументов. Другие конструкторы - на усмотрение
   разработчика. Конкретная ORM библиотека может пренебрегать данным правилом.
2. Доступ к свойствам должен осуществляться только через геттеры `getИмяСвойства` (для boolean допустим
   геттер `isИмяСвойства`) и сеттеры `setИмяСвойства`. Конкретная ORM библиотека может пренебрегать правилом доступа
   через геттеры и сеттеры.
3. Entity класс должен быть классов верхнего уровня.
4. Entity класс, его методы и свойства не могут быть final.
5. Перечисления и интерфейсы не могут быть entity классами.
6. Абстрактные и не абстрактные классы могут быть entity классами.

### Наследование ENTITY классов

1. Entity классы поддерживают наследование и полиморфные запросы и ассоциации.
2. Entity классы могут расширять классы, не являющиеся сущностями и наоборот.
3. Стратегии наследования:
    1) родительский класс не является entity классом
    2) SINGLE_TABLE - поля родителя и дочернего класса будут столбцами одной таблицы (по имени родительского класса).
       Для того, что ORM мог определить, к кому классу относятся те или иные столбцы единой таблицы, в таблице будет
       создан дополнительный столбец DTYPE VARCHAR(255). Можно изменить название столбца и его тип соответствующими
       аннотациями
    3) JOINED - для родительского и дочернего классов создаются отдельные таблицы. Поля родителя будут находиться в его
       таблице, поля дочерних классов - в их таблицах. Единственный дублирующийся столбец - `@Id` столбец. По нему
       таблицы дочерних классов будут связаны с таблицей родительского
    4) TABLE_PER_CLASS - для родительского и дочернего классов создаются отдельные таблицы. Унаследованные свойства -
       столбцы в таблицах дочернего класса. Таблицы не имеют связей друг с другом.

### Требования к полям ENTITY классов

1. Поля entity классов могут быть следующих типов (jpa 3.0):
    1) Примитивы
    2) Обертки над примитивами
    3) java.math.BigInteger, java.math.BigDecimal
    4) Строки
    5) Типы данных для работы с датой и временем, включая пакет java.time
    6) Перечисления
    7) Entity типы
    8) Коллекции entity типов
    9) Embeddable типы (классы, отмеченные @Embeddable аннотацией)
    10) Коллекции embeddable типов
    11) Другие типы, реализующие Serializable интерфейс

2. Коллекции и мапы должны быть инициализированы, доступ к свойствам-коллекциям должен осуществляться через тип
   интерфейса.

### Связи между сущностями

1. Многие ко многим (двунаправленная и однонаправленная)
2. Многие к одному (двунаправленная и однонаправленная)
3. Один ко многим (противоположная сторона двунаправленной связи 'Многие к одному')
4. Один к одному

Стратегии извлечения данных в контексте связей:

1. FetchType.EAGER - при извлечении данных сущности, автоматически подтягиваются данные о связанных с ней сущностях.
   Например, получение задачи автоматически подтянет список исполнителей.
2. FetchType.Lazy - данные о связанных сущностях подтягиваются по требованию, при обращении к соответствующим свойствам.
   Например, получение задачи не подтянет список исполнителей.

Стратегии транзиентных операций в контексте связей:

1. CascadeType.PERSISTS - транзиентное добавление данных. Например, экземпляр задачи ссылается на ее исполнителя, при
   добавлении задачи в таблицу, информация об исполнителе будет добавлена автоматически.
2. CascadeType.MERGE - транзиентное обновление.
3. CascadeType.REMOVE или CascadeType.DELETE (hibernate) - транзиентное удаление данных.
4. CascadeType.DETACH - транзиентное удаление данных из области видимости ORM.
5. CascadeType.REFRESH - обновляет состояние сущности в соответствии с состоянием БД.
6. CascadeType.ALL - поддерживаются все операции.

### Этапы жизненного цикла сущности:

1. Transient - экземпляр entity класса создан, но не был помещен в контекст ORM (объект вне области видимости ORM),
   данных об объекте нет в БД.
2. Managed - объект в контексте ORM. ORM знает обо всех изменениях объекта. Могут быть сгенерированы INSERT или
   UPDATE запросы. В состояние managed объект находится после вызовов методов persists или merge.
3. Detached - объект удален из контекста ORM. Состояние detached объект приобретает после вызова метода detached.
4. Removed - объект удален из контекста ORM. Может быть сгенерирован DELETE запрос для удаления записи из таблицы.
   Состояние removed объект приобретает после вызова методов remove или delete.
